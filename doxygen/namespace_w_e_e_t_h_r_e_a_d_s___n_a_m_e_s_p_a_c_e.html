<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>Rocky: WEETHREADS_NAMESPACE Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">Rocky
   &#160;<span id="projectnumber">0.1.0</span>
   </div>
   <div id="projectbrief">Geospatial Terrain Engine</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">WEETHREADS_NAMESPACE Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1cancelable.html">cancelable</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1jobpool.html">jobpool</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a69760b7c7401076ef4d75b606bdee31b"><td class="memTemplParams" colspan="2">template&lt;class T &gt; </td></tr>
<tr class="memitem:a69760b7c7401076ef4d75b606bdee31b"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a69760b7c7401076ef4d75b606bdee31b">promise</a> = <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt; T &gt;</td></tr>
<tr class="separator:a69760b7c7401076ef4d75b606bdee31b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a214f4e0d19bcfaa51108b239da4ed520"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a214f4e0d19bcfaa51108b239da4ed520">jobgroup</a> = <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1detail_1_1semaphore.html">detail::semaphore</a></td></tr>
<tr class="separator:a214f4e0d19bcfaa51108b239da4ed520"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a20c3990809738942dfcb482afe32d534"><td class="memItemLeft" align="right" valign="top"><a id="a20c3990809738942dfcb482afe32d534"></a>
WEETHREADS_EXPORT detail::runtime &amp;&#160;</td><td class="memItemRight" valign="bottom"><b>instance</b> ()</td></tr>
<tr class="separator:a20c3990809738942dfcb482afe32d534"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a448cb0d894d1fbc5525749ece4c22011"><td class="memItemLeft" align="right" valign="top"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1jobpool.html">jobpool</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a448cb0d894d1fbc5525749ece4c22011">get_pool</a> (const std::string &amp;name={})</td></tr>
<tr class="separator:a448cb0d894d1fbc5525749ece4c22011"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a85dac3a28ad20d6538540acda1f00788"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a85dac3a28ad20d6538540acda1f00788">dispatch</a> (std::function&lt; void()&gt; task, const <a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a> &amp;<a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a>={})</td></tr>
<tr class="separator:a85dac3a28ad20d6538540acda1f00788"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a356290361bc01a4f58ab2cd5baff1976"><td class="memTemplParams" colspan="2">template&lt;typename FUNC , typename T  = typename detail::result_of_t&lt;FUNC(cancelable&amp;)&gt;&gt; </td></tr>
<tr class="memitem:a356290361bc01a4f58ab2cd5baff1976"><td class="memTemplItemLeft" align="right" valign="top"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt; T &gt;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a356290361bc01a4f58ab2cd5baff1976">dispatch</a> (FUNC task, const <a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a> &amp;<a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a>={}, <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt; T &gt; <a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a69760b7c7401076ef4d75b606bdee31b">promise</a>={})</td></tr>
<tr class="separator:a356290361bc01a4f58ab2cd5baff1976"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac5dd4daf4211edd7991d37a70b06071f"><td class="memItemLeft" align="right" valign="top"><a id="ac5dd4daf4211edd7991d37a70b06071f"></a>
metrics *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#ac5dd4daf4211edd7991d37a70b06071f">get_metrics</a> ()</td></tr>
<tr class="memdesc:ac5dd4daf4211edd7991d37a70b06071f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metrics for all job pool. <br /></td></tr>
<tr class="separator:ac5dd4daf4211edd7991d37a70b06071f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a44c2cbf7e02e7cccc95570f475d801da"><td class="memItemLeft" align="right" valign="top"><a id="a44c2cbf7e02e7cccc95570f475d801da"></a>
void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a44c2cbf7e02e7cccc95570f475d801da">shutdown</a> ()</td></tr>
<tr class="memdesc:a44c2cbf7e02e7cccc95570f475d801da"><td class="mdescLeft">&#160;</td><td class="mdescRight">stop all threads, wait for them to exit, and shut down the system <br /></td></tr>
<tr class="separator:a44c2cbf7e02e7cccc95570f475d801da"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a303f59bef107afaaac2df650fab81426"><td class="memItemLeft" align="right" valign="top"><a id="a303f59bef107afaaac2df650fab81426"></a>
bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a303f59bef107afaaac2df650fab81426">alive</a> ()</td></tr>
<tr class="memdesc:a303f59bef107afaaac2df650fab81426"><td class="mdescLeft">&#160;</td><td class="mdescRight">Whether the weethreads runtime is still alive (has not been shutdown) <br /></td></tr>
<tr class="separator:a303f59bef107afaaac2df650fab81426"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a851ffeba28b12e1c256012b3e8277dbd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a851ffeba28b12e1c256012b3e8277dbd">set_thread_name_function</a> (std::function&lt; void(const char *)&gt; f)</td></tr>
<tr class="separator:a851ffeba28b12e1c256012b3e8277dbd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>WeeThreads is an API for scheduling a task to run in the background.</p>
<p>WeeThreads is header-only and has no dependencies aside from the STL.</p>
<p>Usage:</p>
<p>Use this macro somewhere in your app. Put it in a .cpp file if you plan to use multiple modules, DLLs, etc.:</p>
<p>WEETHREADS_INSTANCE;</p>
<p>Example: Spawn a job with no return value (fire and forget):</p>
<p>auto job = []() { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; }; jobs::dispatch(job);</p>
<p>Example: Spawn a job and get a future result:</p>
<p>auto job = [](jobs::cancelable&amp;) { return 7; }; jobs::future&lt;int&gt; result = jobs::dispatch(job); // later... if (result.available()) std::cout &lt;&lt; "Result = " &lt;&lt; result.value() &lt;&lt; std::endl; else if (result.canceled()) std::cout &lt;&lt; "Job was canceled" &lt;&lt; std::endl; else // still running.... come back later</p>
<p>Example: Spawn a job and wait for it to complete:</p>
<p>auto job = [url](jobs::cancelable&amp;) { return fetch_data_from_network(url); }; auto result = jobs::dispatch(job); auto value = result.join();</p>
<p>Example: Spwan a job with some context information:</p>
<p>auto job = []() { std::cout &lt;&lt; "Hello, world!" &lt;&lt; std::endl; }; jobs::context context; context.name = "My Job"; context.pool = jobs::get_pool("My Job Pool"); context.priority = []() { return 1.0f; }; jobs::dispatch(job, context);</p>
<p>Example: Check for cancelation within a job:</p>
<p>auto job = [url](jobs::cancelable&amp; state) { std::string data; if (!state.canceled()) data = fetch_data_from_network(url); return data; };</p>
<p>auto result = jobs::dispatch(job); // if "result" goes out of scope, "state.canceled()" in the job will return true</p>
<p>This SDK exists because existing solutions do not support two things we need: automatic job cancelation, and job prioritization. This system acheives cancelation by tracking the reference count of the shared result object contained in the Future object; if that reference count goes to one, it means that ONLY the scheduler knows about the job, and no one else is around to fetch its result. In this case, future.canceled() returns true. It's up to the task itself to check the cancelable&amp; object if it wants to quit early. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a214f4e0d19bcfaa51108b239da4ed520"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a214f4e0d19bcfaa51108b239da4ed520">&#9670;&nbsp;</a></span>jobgroup</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a214f4e0d19bcfaa51108b239da4ed520">WEETHREADS_NAMESPACE::jobgroup</a> = typedef <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1detail_1_1semaphore.html">detail::semaphore</a></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Include a jobgroup in a context to group together multiple jobs. You can then call <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1detail_1_1semaphore.html#ad585b0e891b386c104ab9c66af177bcb">jobgroup::join()</a> to wait for the whole group to finish. </p>

</div>
</div>
<a id="a69760b7c7401076ef4d75b606bdee31b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a69760b7c7401076ef4d75b606bdee31b">&#9670;&nbsp;</a></span>promise</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;class T &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespace_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e.html#a69760b7c7401076ef4d75b606bdee31b">WEETHREADS_NAMESPACE::promise</a> = typedef <a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt;T&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>in the "promise/future" pattern, we use the same object for both, but here's an alias for clarity. </p>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="a356290361bc01a4f58ab2cd5baff1976"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a356290361bc01a4f58ab2cd5baff1976">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename FUNC , typename T  = typename detail::result_of_t&lt;FUNC(cancelable&amp;)&gt;&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt;T&gt; WEETHREADS_NAMESPACE::dispatch </td>
          <td>(</td>
          <td class="paramtype">FUNC&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em> = <code>{}</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1future.html">future</a>&lt; T &gt;&#160;</td>
          <td class="paramname"><em>promise</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dispatches a job and immediately returns a future result. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Function to run in a thread. Prototype is T(cancelable&amp;) </td></tr>
    <tr><td class="paramname">context</td><td>Optional configuration for the asynchronous function call </td></tr>
    <tr><td class="paramname">promise</td><td>Optional user-supplied promise object </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Future result of the async function call </dd></dl>

</div>
</div>
<a id="a85dac3a28ad20d6538540acda1f00788"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a85dac3a28ad20d6538540acda1f00788">&#9670;&nbsp;</a></span>dispatch() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WEETHREADS_NAMESPACE::dispatch </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void()&gt;&#160;</td>
          <td class="paramname"><em>task</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="struct_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1context.html">context</a> &amp;&#160;</td>
          <td class="paramname"><em>context</em> = <code>{}</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Dispatches a job with no return value. Fire and forget. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">task</td><td>Function to run in a thread. Prototype is void(void). </td></tr>
    <tr><td class="paramname">context</td><td>Optional configuration for the asynchronous function call </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a448cb0d894d1fbc5525749ece4c22011"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a448cb0d894d1fbc5525749ece4c22011">&#9670;&nbsp;</a></span>get_pool()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="class_w_e_e_t_h_r_e_a_d_s___n_a_m_e_s_p_a_c_e_1_1jobpool.html">jobpool</a>* WEETHREADS_NAMESPACE::get_pool </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>{}</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns the job pool with the given name, creating a new one if it doesn't already exist. If you don't specify a name, a default pool is used. </p>

</div>
</div>
<a id="a851ffeba28b12e1c256012b3e8277dbd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a851ffeba28b12e1c256012b3e8277dbd">&#9670;&nbsp;</a></span>set_thread_name_function()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">void WEETHREADS_NAMESPACE::set_thread_name_function </td>
          <td>(</td>
          <td class="paramtype">std::function&lt; void(const char *)&gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Install a function that the SDK can use to set job pool thread names when it spawns them. </p>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
